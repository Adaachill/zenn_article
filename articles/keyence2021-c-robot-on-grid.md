---
title: "Keyence2021 C - Robot on Grid解説[python]"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["atcoder","競プロ","python",]
published: false
---

# URL
https://atcoder.jp/contests/keyence2021/tasks/keyence2021_c

# 制約
$$ 2 <= H,W<=5000 $$
$$ 0<= K <= min(HW,2*10^5)$$
$$ 1 <= hi<= H  $$
$$ 1 <= wi<= W $$

# 問題概要
- H*Wのgrid がある。それぞれのマスにはR,D,Xのいずれかが書き込める
- Kこのマス(hi,wi)を選んで文字Ciを書き込んだ
- 残りのH*W-K のそれぞれの書き込み方（3^(H*W-K)通り)での移動方法の総和を998244353で割ったあまりを答えよ
- (1,1)から(H,W)まで移動できるようなルート　
- R ならj+1 , Dならi+1に移動。X なら両方いける
# 提出コード
```python

```

# 考察
- 問題から全探索はできないので、同じような状態をまとめる必要がある。
- それぞれのパスに対して、それを使ってゴールする書き込み方が何通りあるかを数えたい
  - 書き込み方はそのパス上にある書き込まれていないマスをi個とした時、i^2*3^(HW-i-K)となる
  - 証明：パス上のマスはXかRorDのうちパスに従うものの２通りあり、パス上でないマスはどの文字でも良いため
- 陽にパスに対して全探索すると1000C500通りでTLEするのでDPでまとめる必要がある
  - dp[i][j] := (i,j)に到達するような書き込み方でのパスの総和　としたい
  - 一方で、それぞれのpathに対して何個の書き込まれていないマスを通ったかの情報を持ちたい
  - しかし、それを状態としてもつとdp[i][j][k] となって、5000*5000*5000でTLEする。
    - 書き込まれていないマスを通ったらパスの総和を3で割ることで帳尻を合わせる
  - 答えはdp[h][w]*　3^(HW-K) となる。
- 漸化式を考えると、配るDPの方が元のマスの値を計算しやすいので、それで考えて
  - if grid[i][j] == "X" : dp[i+1][j] += dp[i][j],dp[i][j+1] += dp[i][j]
  - elif grid[i][j] == "R": dp[i][j+1] += dp[i][j]
  - elif grid[i][j] == "D" : dp[i+1][j] += dp[i][j]
  - else: p[i+1][j] += 2/3*dp[i][j],dp[i][j+1] += 2/3*dp[i][j]
  という式になる

# 実装方針
- 3で割り続けるので、初期値をどうするかがきも
- 初期値を1にして計算するとTLE。。
- 

# 次回への反省
- 

# 参考
