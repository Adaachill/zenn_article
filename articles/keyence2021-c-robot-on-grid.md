---
title: "解説[python]"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["atcoder","競プロ","python",]
published: false
---

# URL
https://atcoder.jp/contests/keyence2021/tasks/keyence2021_c

# 制約
$$ 2 <= H,W<=5000 $$
$$ 0<= K <= min(HW,2*10^5)$$
$$ 1 <= hi<= H  $$
$$ 1 <= wi<= W $$

# 問題概要
- H*Wのgrid がある。それぞれのマスにはR,D,Xのいずれかが書き込める
- Kこのマス(hi,wi)を選んで文字Ciを書き込んだ
- 残りのH*W-K のそれぞれの書き込み方（3^(H*W-K)通り)での移動方法の総和を998244353で割ったあまりを答えよ
- (1,1)から(H,W)まで移動できるようなルート　
- R ならj+1 , Dならi+1に移動。X なら両方いける
# 提出コード
```python

```

# 考察
- 問題から全探索はできないので、同じような状態をまとめる必要がある。
- 個別の書き込み方で考えると、DPで計算できる。
- (i,j)以降の状態が同じならそこまでの距離を単純に足していくことができる
- それだとパスが多すぎるのでルートに対してdpを計算すると良い？
- (i,j)へのパスは、i+jCi通りある。(0-indexで)
- 前処理としてそれを全部計算できる？
- 前通りに対して、計算すればいいから前計算がO(HW)で答えの計算もO(HW)でいけそう
- 漸化式を考える

# 実装方針
- DP_path_f[i][j]:= 全pathの中で(0,0)から(i,j)にいける塗り方、生き方の数
DP_path_f[i][j] = DP_path_f[i-1][j]*2 + DP_path_f[i][j-1]*2
- DP_path_r[i][j]:= 全pathの中で(W-1,H-1)から(i,j)にいける塗り方の数
DP_path_r[i][j] = DP_path_r[i+1][j]*2 + DP_path_r[i][j+1]*2
- DP_ans[i][j] = DP_path_r[i][j]*DP_path_f[i][j]
- 答えは？？?
[i][j]にいくまでの個数はそれからあとが任意でいいなら3^(w-i+h-j)になる。
- 通れないやつをカウントしても意味がないので、dp_path[w-1][h-1]が答え？
簡単すぎない？実装してみる。

# 次回への反省
- 

# 参考
