---
title: "木DPの練習2　AGC009 B - Tournamnt メモ[python]"
emoji: "✨"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["atcoder","競プロ","python","数え上げ","木DP"]
published: true
---

ABC187Eで木DPが出て実装でつまづいたので練習する。第二回
第一回(https://zenn.dev/articles/abc_036_d_tree_dp)

# URL
https://atcoder.jp/contests/agc009/tasks/agc009_b

# 問題概要
- N 人からなるトーナメント表があり、１番の人が優勝している
- ２~N番の人に関してどの人に負けたかが与えられる
- トーナメントの深さとして最小なもの（深さとは、根（優勝）からの距離が最も遠いノードまでの距離）

#　制約
N<=10**5

# 提出コード
```python

```

# 考察
- 入力の性質：トーナメントは二分木である
  - トーナメント表は連結かつループがないので木である
  - 一度に戦うのは二人なので二分木
  - 今回は節を考えたくないので1を根とした木に変換する
- 言い換え：
  - トーナメント表を1が根で、それ以外のそれぞれのノードが自分が負けた人を親にもつ木として言い換える
- dp[i] : トーナメント表でのノードi が負けた時点での深さ（一回戦負けなら1)
  - 漸化式：dp[i] = max(dp[j]+k) #  j は i の子ノード、kはdp[j]を降順にソートした時の番号、最大なら1
  - 毎回ソートするとO(N*NlogN)かかってTLEする? > とりあえず実装する
  - トーナメントの深さ = max(入力中の1の個数,他のノードが持つ深さ) として表現できる

# 次回への反省
- 考察に時間がかかった 50min
- ソートするのは思いついたがそれがO(NlogN)で終わる？
- それぞれに対してソートしないといけないからO(N*NlogN)では？と思って沼った
- 辺の持ち方とスコアの持ち方に手間取った